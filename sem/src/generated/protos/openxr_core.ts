// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.1
// source: protos/openxr_core.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "openxr";

export interface Vector2 {
  x: number;
  y: number;
}

export interface Extent2 {
  width: number;
  height: number;
}

export interface Vector3 {
  x: number;
  y: number;
  z: number;
}

export interface Extent3 {
  width: number;
  height: number;
  depth: number;
}

export interface Quaternion {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface Rect2D {
  offset: Vector2 | undefined;
  extent: Extent2 | undefined;
}

export interface Rect3D {
  offset: Vector3 | undefined;
  extent: Extent3 | undefined;
}

/**
 * All angles are in radians and are the OpenXR FOV
 * https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#angles
 */
export interface Fov {
  /** negative */
  angleLeft: number;
  /** positive */
  angleRight: number;
  /** positive */
  angleUp: number;
  /** negative */
  angleDown: number;
}

/**
 * This is the OpenXR Coordinate System:
 *  https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#coordinate-system
 */
export interface Pose {
  orientation: Quaternion | undefined;
  position: Vector3 | undefined;
}

function createBaseVector2(): Vector2 {
  return { x: 0, y: 0 };
}

export const Vector2: MessageFns<Vector2> = {
  encode(message: Vector2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vector2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector2 {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Vector2): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector2>, I>>(base?: I): Vector2 {
    return Vector2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector2>, I>>(object: I): Vector2 {
    const message = createBaseVector2();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseExtent2(): Extent2 {
  return { width: 0, height: 0 };
}

export const Extent2: MessageFns<Extent2> = {
  encode(message: Extent2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(13).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(21).float(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Extent2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtent2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.width = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.height = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Extent2 {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: Extent2): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Extent2>, I>>(base?: I): Extent2 {
    return Extent2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Extent2>, I>>(object: I): Extent2 {
    const message = createBaseExtent2();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseVector3(): Vector3 {
  return { x: 0, y: 0, z: 0 };
}

export const Vector3: MessageFns<Vector3> = {
  encode(message: Vector3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vector3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector3 {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: Vector3): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector3>, I>>(base?: I): Vector3 {
    return Vector3.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector3>, I>>(object: I): Vector3 {
    const message = createBaseVector3();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseExtent3(): Extent3 {
  return { width: 0, height: 0, depth: 0 };
}

export const Extent3: MessageFns<Extent3> = {
  encode(message: Extent3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(13).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(21).float(message.height);
    }
    if (message.depth !== 0) {
      writer.uint32(29).float(message.depth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Extent3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtent3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.width = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.height = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.depth = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Extent3 {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
    };
  },

  toJSON(message: Extent3): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    if (message.depth !== 0) {
      obj.depth = message.depth;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Extent3>, I>>(base?: I): Extent3 {
    return Extent3.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Extent3>, I>>(object: I): Extent3 {
    const message = createBaseExtent3();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.depth = object.depth ?? 0;
    return message;
  },
};

function createBaseQuaternion(): Quaternion {
  return { x: 0, y: 0, z: 0, w: 0 };
}

export const Quaternion: MessageFns<Quaternion> = {
  encode(message: Quaternion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.w !== 0) {
      writer.uint32(37).float(message.w);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Quaternion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuaternion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.w = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Quaternion {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      w: isSet(object.w) ? globalThis.Number(object.w) : 0,
    };
  },

  toJSON(message: Quaternion): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.w !== 0) {
      obj.w = message.w;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quaternion>, I>>(base?: I): Quaternion {
    return Quaternion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quaternion>, I>>(object: I): Quaternion {
    const message = createBaseQuaternion();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.w = object.w ?? 0;
    return message;
  },
};

function createBaseRect2D(): Rect2D {
  return { offset: undefined, extent: undefined };
}

export const Rect2D: MessageFns<Rect2D> = {
  encode(message: Rect2D, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== undefined) {
      Vector2.encode(message.offset, writer.uint32(10).fork()).join();
    }
    if (message.extent !== undefined) {
      Extent2.encode(message.extent, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rect2D {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRect2D();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offset = Vector2.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extent = Extent2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rect2D {
    return {
      offset: isSet(object.offset) ? Vector2.fromJSON(object.offset) : undefined,
      extent: isSet(object.extent) ? Extent2.fromJSON(object.extent) : undefined,
    };
  },

  toJSON(message: Rect2D): unknown {
    const obj: any = {};
    if (message.offset !== undefined) {
      obj.offset = Vector2.toJSON(message.offset);
    }
    if (message.extent !== undefined) {
      obj.extent = Extent2.toJSON(message.extent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rect2D>, I>>(base?: I): Rect2D {
    return Rect2D.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rect2D>, I>>(object: I): Rect2D {
    const message = createBaseRect2D();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Vector2.fromPartial(object.offset)
      : undefined;
    message.extent = (object.extent !== undefined && object.extent !== null)
      ? Extent2.fromPartial(object.extent)
      : undefined;
    return message;
  },
};

function createBaseRect3D(): Rect3D {
  return { offset: undefined, extent: undefined };
}

export const Rect3D: MessageFns<Rect3D> = {
  encode(message: Rect3D, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== undefined) {
      Vector3.encode(message.offset, writer.uint32(10).fork()).join();
    }
    if (message.extent !== undefined) {
      Extent3.encode(message.extent, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rect3D {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRect3D();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offset = Vector3.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extent = Extent3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rect3D {
    return {
      offset: isSet(object.offset) ? Vector3.fromJSON(object.offset) : undefined,
      extent: isSet(object.extent) ? Extent3.fromJSON(object.extent) : undefined,
    };
  },

  toJSON(message: Rect3D): unknown {
    const obj: any = {};
    if (message.offset !== undefined) {
      obj.offset = Vector3.toJSON(message.offset);
    }
    if (message.extent !== undefined) {
      obj.extent = Extent3.toJSON(message.extent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rect3D>, I>>(base?: I): Rect3D {
    return Rect3D.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rect3D>, I>>(object: I): Rect3D {
    const message = createBaseRect3D();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Vector3.fromPartial(object.offset)
      : undefined;
    message.extent = (object.extent !== undefined && object.extent !== null)
      ? Extent3.fromPartial(object.extent)
      : undefined;
    return message;
  },
};

function createBaseFov(): Fov {
  return { angleLeft: 0, angleRight: 0, angleUp: 0, angleDown: 0 };
}

export const Fov: MessageFns<Fov> = {
  encode(message: Fov, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.angleLeft !== 0) {
      writer.uint32(13).float(message.angleLeft);
    }
    if (message.angleRight !== 0) {
      writer.uint32(21).float(message.angleRight);
    }
    if (message.angleUp !== 0) {
      writer.uint32(29).float(message.angleUp);
    }
    if (message.angleDown !== 0) {
      writer.uint32(37).float(message.angleDown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fov {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFov();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.angleLeft = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.angleRight = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.angleUp = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.angleDown = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fov {
    return {
      angleLeft: isSet(object.angleLeft) ? globalThis.Number(object.angleLeft) : 0,
      angleRight: isSet(object.angleRight) ? globalThis.Number(object.angleRight) : 0,
      angleUp: isSet(object.angleUp) ? globalThis.Number(object.angleUp) : 0,
      angleDown: isSet(object.angleDown) ? globalThis.Number(object.angleDown) : 0,
    };
  },

  toJSON(message: Fov): unknown {
    const obj: any = {};
    if (message.angleLeft !== 0) {
      obj.angleLeft = message.angleLeft;
    }
    if (message.angleRight !== 0) {
      obj.angleRight = message.angleRight;
    }
    if (message.angleUp !== 0) {
      obj.angleUp = message.angleUp;
    }
    if (message.angleDown !== 0) {
      obj.angleDown = message.angleDown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fov>, I>>(base?: I): Fov {
    return Fov.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fov>, I>>(object: I): Fov {
    const message = createBaseFov();
    message.angleLeft = object.angleLeft ?? 0;
    message.angleRight = object.angleRight ?? 0;
    message.angleUp = object.angleUp ?? 0;
    message.angleDown = object.angleDown ?? 0;
    return message;
  },
};

function createBasePose(): Pose {
  return { orientation: undefined, position: undefined };
}

export const Pose: MessageFns<Pose> = {
  encode(message: Pose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orientation !== undefined) {
      Quaternion.encode(message.orientation, writer.uint32(10).fork()).join();
    }
    if (message.position !== undefined) {
      Vector3.encode(message.position, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orientation = Quaternion.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Vector3.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pose {
    return {
      orientation: isSet(object.orientation) ? Quaternion.fromJSON(object.orientation) : undefined,
      position: isSet(object.position) ? Vector3.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: Pose): unknown {
    const obj: any = {};
    if (message.orientation !== undefined) {
      obj.orientation = Quaternion.toJSON(message.orientation);
    }
    if (message.position !== undefined) {
      obj.position = Vector3.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pose>, I>>(base?: I): Pose {
    return Pose.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pose>, I>>(object: I): Pose {
    const message = createBasePose();
    message.orientation = (object.orientation !== undefined && object.orientation !== null)
      ? Quaternion.fromPartial(object.orientation)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector3.fromPartial(object.position)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
