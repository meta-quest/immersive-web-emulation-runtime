// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v5.29.1
// source: protos/openxr_core.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';

export const protobufPackage = 'openxr';

export interface Vector2 {
	x: number;
	y: number;
}

export interface Extent2 {
	width: number;
	height: number;
}

export interface Vector3 {
	x: number;
	y: number;
	z: number;
}

export interface Extent3 {
	width: number;
	height: number;
	depth: number;
}

export interface Quaternion {
	x: number;
	y: number;
	z: number;
	w: number;
}

export interface Rect2D {
	offset: Vector2 | undefined;
	extent: Extent2 | undefined;
}

export interface Rect3D {
	offset: Vector3 | undefined;
	extent: Extent3 | undefined;
}

/**
 * All angles are in radians and are the OpenXR FOV
 * https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#angles
 */
export interface Fov {
	/** negative */
	angleLeft: number;
	/** positive */
	angleRight: number;
	/** positive */
	angleUp: number;
	/** negative */
	angleDown: number;
}

/**
 * This is the OpenXR Coordinate System:
 *  https://registry.khronos.org/OpenXR/specs/1.0/html/xrspec.html#coordinate-system
 */
export interface Pose {
	orientation: Quaternion | undefined;
	position: Vector3 | undefined;
}

function createBaseVector2(): Vector2 {
	return { x: 0, y: 0 };
}

export const Vector2: MessageFns<Vector2> = {
	encode(
		message: Vector2,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.x !== 0) {
			writer.uint32(13).float(message.x);
		}
		if (message.y !== 0) {
			writer.uint32(21).float(message.y);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Vector2 {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseVector2();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 13) {
						break;
					}

					message.x = reader.float();
					continue;
				}
				case 2: {
					if (tag !== 21) {
						break;
					}

					message.y = reader.float();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Vector2 {
		return {
			x: isSet(object.x) ? globalThis.Number(object.x) : 0,
			y: isSet(object.y) ? globalThis.Number(object.y) : 0,
		};
	},

	toJSON(message: Vector2): unknown {
		const obj: any = {};
		if (message.x !== 0) {
			obj.x = message.x;
		}
		if (message.y !== 0) {
			obj.y = message.y;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Vector2>, I>>(base?: I): Vector2 {
		return Vector2.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Vector2>, I>>(object: I): Vector2 {
		const message = createBaseVector2();
		message.x = object.x ?? 0;
		message.y = object.y ?? 0;
		return message;
	},
};

function createBaseExtent2(): Extent2 {
	return { width: 0, height: 0 };
}

export const Extent2: MessageFns<Extent2> = {
	encode(
		message: Extent2,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.width !== 0) {
			writer.uint32(13).float(message.width);
		}
		if (message.height !== 0) {
			writer.uint32(21).float(message.height);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Extent2 {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseExtent2();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 13) {
						break;
					}

					message.width = reader.float();
					continue;
				}
				case 2: {
					if (tag !== 21) {
						break;
					}

					message.height = reader.float();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Extent2 {
		return {
			width: isSet(object.width) ? globalThis.Number(object.width) : 0,
			height: isSet(object.height) ? globalThis.Number(object.height) : 0,
		};
	},

	toJSON(message: Extent2): unknown {
		const obj: any = {};
		if (message.width !== 0) {
			obj.width = message.width;
		}
		if (message.height !== 0) {
			obj.height = message.height;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Extent2>, I>>(base?: I): Extent2 {
		return Extent2.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Extent2>, I>>(object: I): Extent2 {
		const message = createBaseExtent2();
		message.width = object.width ?? 0;
		message.height = object.height ?? 0;
		return message;
	},
};

function createBaseVector3(): Vector3 {
	return { x: 0, y: 0, z: 0 };
}

export const Vector3: MessageFns<Vector3> = {
	encode(
		message: Vector3,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.x !== 0) {
			writer.uint32(13).float(message.x);
		}
		if (message.y !== 0) {
			writer.uint32(21).float(message.y);
		}
		if (message.z !== 0) {
			writer.uint32(29).float(message.z);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Vector3 {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseVector3();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 13) {
						break;
					}

					message.x = reader.float();
					continue;
				}
				case 2: {
					if (tag !== 21) {
						break;
					}

					message.y = reader.float();
					continue;
				}
				case 3: {
					if (tag !== 29) {
						break;
					}

					message.z = reader.float();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Vector3 {
		return {
			x: isSet(object.x) ? globalThis.Number(object.x) : 0,
			y: isSet(object.y) ? globalThis.Number(object.y) : 0,
			z: isSet(object.z) ? globalThis.Number(object.z) : 0,
		};
	},

	toJSON(message: Vector3): unknown {
		const obj: any = {};
		if (message.x !== 0) {
			obj.x = message.x;
		}
		if (message.y !== 0) {
			obj.y = message.y;
		}
		if (message.z !== 0) {
			obj.z = message.z;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Vector3>, I>>(base?: I): Vector3 {
		return Vector3.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Vector3>, I>>(object: I): Vector3 {
		const message = createBaseVector3();
		message.x = object.x ?? 0;
		message.y = object.y ?? 0;
		message.z = object.z ?? 0;
		return message;
	},
};

function createBaseExtent3(): Extent3 {
	return { width: 0, height: 0, depth: 0 };
}

export const Extent3: MessageFns<Extent3> = {
	encode(
		message: Extent3,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.width !== 0) {
			writer.uint32(13).float(message.width);
		}
		if (message.height !== 0) {
			writer.uint32(21).float(message.height);
		}
		if (message.depth !== 0) {
			writer.uint32(29).float(message.depth);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Extent3 {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseExtent3();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 13) {
						break;
					}

					message.width = reader.float();
					continue;
				}
				case 2: {
					if (tag !== 21) {
						break;
					}

					message.height = reader.float();
					continue;
				}
				case 3: {
					if (tag !== 29) {
						break;
					}

					message.depth = reader.float();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Extent3 {
		return {
			width: isSet(object.width) ? globalThis.Number(object.width) : 0,
			height: isSet(object.height) ? globalThis.Number(object.height) : 0,
			depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
		};
	},

	toJSON(message: Extent3): unknown {
		const obj: any = {};
		if (message.width !== 0) {
			obj.width = message.width;
		}
		if (message.height !== 0) {
			obj.height = message.height;
		}
		if (message.depth !== 0) {
			obj.depth = message.depth;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Extent3>, I>>(base?: I): Extent3 {
		return Extent3.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Extent3>, I>>(object: I): Extent3 {
		const message = createBaseExtent3();
		message.width = object.width ?? 0;
		message.height = object.height ?? 0;
		message.depth = object.depth ?? 0;
		return message;
	},
};

function createBaseQuaternion(): Quaternion {
	return { x: 0, y: 0, z: 0, w: 0 };
}

export const Quaternion: MessageFns<Quaternion> = {
	encode(
		message: Quaternion,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.x !== 0) {
			writer.uint32(13).float(message.x);
		}
		if (message.y !== 0) {
			writer.uint32(21).float(message.y);
		}
		if (message.z !== 0) {
			writer.uint32(29).float(message.z);
		}
		if (message.w !== 0) {
			writer.uint32(37).float(message.w);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Quaternion {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQuaternion();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 13) {
						break;
					}

					message.x = reader.float();
					continue;
				}
				case 2: {
					if (tag !== 21) {
						break;
					}

					message.y = reader.float();
					continue;
				}
				case 3: {
					if (tag !== 29) {
						break;
					}

					message.z = reader.float();
					continue;
				}
				case 4: {
					if (tag !== 37) {
						break;
					}

					message.w = reader.float();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Quaternion {
		return {
			x: isSet(object.x) ? globalThis.Number(object.x) : 0,
			y: isSet(object.y) ? globalThis.Number(object.y) : 0,
			z: isSet(object.z) ? globalThis.Number(object.z) : 0,
			w: isSet(object.w) ? globalThis.Number(object.w) : 0,
		};
	},

	toJSON(message: Quaternion): unknown {
		const obj: any = {};
		if (message.x !== 0) {
			obj.x = message.x;
		}
		if (message.y !== 0) {
			obj.y = message.y;
		}
		if (message.z !== 0) {
			obj.z = message.z;
		}
		if (message.w !== 0) {
			obj.w = message.w;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Quaternion>, I>>(base?: I): Quaternion {
		return Quaternion.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Quaternion>, I>>(
		object: I,
	): Quaternion {
		const message = createBaseQuaternion();
		message.x = object.x ?? 0;
		message.y = object.y ?? 0;
		message.z = object.z ?? 0;
		message.w = object.w ?? 0;
		return message;
	},
};

function createBaseRect2D(): Rect2D {
	return { offset: undefined, extent: undefined };
}

export const Rect2D: MessageFns<Rect2D> = {
	encode(
		message: Rect2D,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.offset !== undefined) {
			Vector2.encode(message.offset, writer.uint32(10).fork()).join();
		}
		if (message.extent !== undefined) {
			Extent2.encode(message.extent, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Rect2D {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRect2D();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.offset = Vector2.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.extent = Extent2.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Rect2D {
		return {
			offset: isSet(object.offset)
				? Vector2.fromJSON(object.offset)
				: undefined,
			extent: isSet(object.extent)
				? Extent2.fromJSON(object.extent)
				: undefined,
		};
	},

	toJSON(message: Rect2D): unknown {
		const obj: any = {};
		if (message.offset !== undefined) {
			obj.offset = Vector2.toJSON(message.offset);
		}
		if (message.extent !== undefined) {
			obj.extent = Extent2.toJSON(message.extent);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Rect2D>, I>>(base?: I): Rect2D {
		return Rect2D.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Rect2D>, I>>(object: I): Rect2D {
		const message = createBaseRect2D();
		message.offset =
			object.offset !== undefined && object.offset !== null
				? Vector2.fromPartial(object.offset)
				: undefined;
		message.extent =
			object.extent !== undefined && object.extent !== null
				? Extent2.fromPartial(object.extent)
				: undefined;
		return message;
	},
};

function createBaseRect3D(): Rect3D {
	return { offset: undefined, extent: undefined };
}

export const Rect3D: MessageFns<Rect3D> = {
	encode(
		message: Rect3D,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.offset !== undefined) {
			Vector3.encode(message.offset, writer.uint32(10).fork()).join();
		}
		if (message.extent !== undefined) {
			Extent3.encode(message.extent, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Rect3D {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRect3D();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.offset = Vector3.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.extent = Extent3.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Rect3D {
		return {
			offset: isSet(object.offset)
				? Vector3.fromJSON(object.offset)
				: undefined,
			extent: isSet(object.extent)
				? Extent3.fromJSON(object.extent)
				: undefined,
		};
	},

	toJSON(message: Rect3D): unknown {
		const obj: any = {};
		if (message.offset !== undefined) {
			obj.offset = Vector3.toJSON(message.offset);
		}
		if (message.extent !== undefined) {
			obj.extent = Extent3.toJSON(message.extent);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Rect3D>, I>>(base?: I): Rect3D {
		return Rect3D.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Rect3D>, I>>(object: I): Rect3D {
		const message = createBaseRect3D();
		message.offset =
			object.offset !== undefined && object.offset !== null
				? Vector3.fromPartial(object.offset)
				: undefined;
		message.extent =
			object.extent !== undefined && object.extent !== null
				? Extent3.fromPartial(object.extent)
				: undefined;
		return message;
	},
};

function createBaseFov(): Fov {
	return { angleLeft: 0, angleRight: 0, angleUp: 0, angleDown: 0 };
}

export const Fov: MessageFns<Fov> = {
	encode(
		message: Fov,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.angleLeft !== 0) {
			writer.uint32(13).float(message.angleLeft);
		}
		if (message.angleRight !== 0) {
			writer.uint32(21).float(message.angleRight);
		}
		if (message.angleUp !== 0) {
			writer.uint32(29).float(message.angleUp);
		}
		if (message.angleDown !== 0) {
			writer.uint32(37).float(message.angleDown);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Fov {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFov();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 13) {
						break;
					}

					message.angleLeft = reader.float();
					continue;
				}
				case 2: {
					if (tag !== 21) {
						break;
					}

					message.angleRight = reader.float();
					continue;
				}
				case 3: {
					if (tag !== 29) {
						break;
					}

					message.angleUp = reader.float();
					continue;
				}
				case 4: {
					if (tag !== 37) {
						break;
					}

					message.angleDown = reader.float();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Fov {
		return {
			angleLeft: isSet(object.angleLeft)
				? globalThis.Number(object.angleLeft)
				: 0,
			angleRight: isSet(object.angleRight)
				? globalThis.Number(object.angleRight)
				: 0,
			angleUp: isSet(object.angleUp) ? globalThis.Number(object.angleUp) : 0,
			angleDown: isSet(object.angleDown)
				? globalThis.Number(object.angleDown)
				: 0,
		};
	},

	toJSON(message: Fov): unknown {
		const obj: any = {};
		if (message.angleLeft !== 0) {
			obj.angleLeft = message.angleLeft;
		}
		if (message.angleRight !== 0) {
			obj.angleRight = message.angleRight;
		}
		if (message.angleUp !== 0) {
			obj.angleUp = message.angleUp;
		}
		if (message.angleDown !== 0) {
			obj.angleDown = message.angleDown;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Fov>, I>>(base?: I): Fov {
		return Fov.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Fov>, I>>(object: I): Fov {
		const message = createBaseFov();
		message.angleLeft = object.angleLeft ?? 0;
		message.angleRight = object.angleRight ?? 0;
		message.angleUp = object.angleUp ?? 0;
		message.angleDown = object.angleDown ?? 0;
		return message;
	},
};

function createBasePose(): Pose {
	return { orientation: undefined, position: undefined };
}

export const Pose: MessageFns<Pose> = {
	encode(
		message: Pose,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.orientation !== undefined) {
			Quaternion.encode(message.orientation, writer.uint32(10).fork()).join();
		}
		if (message.position !== undefined) {
			Vector3.encode(message.position, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Pose {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePose();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.orientation = Quaternion.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.position = Vector3.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Pose {
		return {
			orientation: isSet(object.orientation)
				? Quaternion.fromJSON(object.orientation)
				: undefined,
			position: isSet(object.position)
				? Vector3.fromJSON(object.position)
				: undefined,
		};
	},

	toJSON(message: Pose): unknown {
		const obj: any = {};
		if (message.orientation !== undefined) {
			obj.orientation = Quaternion.toJSON(message.orientation);
		}
		if (message.position !== undefined) {
			obj.position = Vector3.toJSON(message.position);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Pose>, I>>(base?: I): Pose {
		return Pose.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Pose>, I>>(object: I): Pose {
		const message = createBasePose();
		message.orientation =
			object.orientation !== undefined && object.orientation !== null
				? Quaternion.fromPartial(object.orientation)
				: undefined;
		message.position =
			object.position !== undefined && object.position !== null
				? Vector3.fromPartial(object.position)
				: undefined;
		return message;
	},
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

export type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
	? globalThis.Array<DeepPartial<U>>
	: T extends ReadonlyArray<infer U>
	? ReadonlyArray<DeepPartial<U>>
	: T extends {}
	? { [K in keyof T]?: DeepPartial<T[K]> }
	: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
	  };

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

export interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
